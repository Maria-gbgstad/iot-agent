// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package conversion

import (
	"context"
	"github.com/rs/zerolog"
	"sync"
)

// Ensure, that MessageConverterMock does implement MessageConverter.
// If this is not the case, regenerate this file with moq.
var _ MessageConverter = &MessageConverterMock{}

// MessageConverterMock is a mock implementation of MessageConverter.
//
// 	func TestSomethingThatUsesMessageConverter(t *testing.T) {
//
// 		// make and configure a mocked MessageConverter
// 		mockedMessageConverter := &MessageConverterMock{
// 			ConvertPayloadFunc: func(ctx context.Context, log zerolog.Logger, internalID string, msg []byte) (InternalMessageFormat, error) {
// 				panic("mock out the ConvertPayload method")
// 			},
// 		}
//
// 		// use mockedMessageConverter in code that requires MessageConverter
// 		// and then make assertions.
//
// 	}
type MessageConverterMock struct {
	// ConvertPayloadFunc mocks the ConvertPayload method.
	ConvertPayloadFunc func(ctx context.Context, log zerolog.Logger, internalID string, msg []byte) (InternalMessageFormat, error)

	// calls tracks calls to the methods.
	calls struct {
		// ConvertPayload holds details about calls to the ConvertPayload method.
		ConvertPayload []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Log is the log argument value.
			Log zerolog.Logger
			// InternalID is the internalID argument value.
			InternalID string
			// Msg is the msg argument value.
			Msg []byte
		}
	}
	lockConvertPayload sync.RWMutex
}

// ConvertPayload calls ConvertPayloadFunc.
func (mock *MessageConverterMock) ConvertPayload(ctx context.Context, log zerolog.Logger, internalID string, msg []byte) (InternalMessageFormat, error) {
	if mock.ConvertPayloadFunc == nil {
		panic("MessageConverterMock.ConvertPayloadFunc: method is nil but MessageConverter.ConvertPayload was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Log        zerolog.Logger
		InternalID string
		Msg        []byte
	}{
		Ctx:        ctx,
		Log:        log,
		InternalID: internalID,
		Msg:        msg,
	}
	mock.lockConvertPayload.Lock()
	mock.calls.ConvertPayload = append(mock.calls.ConvertPayload, callInfo)
	mock.lockConvertPayload.Unlock()
	return mock.ConvertPayloadFunc(ctx, log, internalID, msg)
}

// ConvertPayloadCalls gets all the calls that were made to ConvertPayload.
// Check the length with:
//     len(mockedMessageConverter.ConvertPayloadCalls())
func (mock *MessageConverterMock) ConvertPayloadCalls() []struct {
	Ctx        context.Context
	Log        zerolog.Logger
	InternalID string
	Msg        []byte
} {
	var calls []struct {
		Ctx        context.Context
		Log        zerolog.Logger
		InternalID string
		Msg        []byte
	}
	mock.lockConvertPayload.RLock()
	calls = mock.calls.ConvertPayload
	mock.lockConvertPayload.RUnlock()
	return calls
}
